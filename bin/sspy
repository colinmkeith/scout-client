#!/usr/bin/env ruby -wKU

DEFAULT_SERVER = "localhost:8000"

# set the server url
if ARGV.first == "-s"
  ARGV.shift
  $server = ARGV.shift
else
  $server = DEFAULT_SERVER
end

URLS   = { :plan   => "/clients/CLIENT_ID/plugins.spy",
           :report => "/clients/CLIENT_ID/plugins/PLUGIN_ID/reports.spy",
           :error  => "/clients/CLIENT_ID/plugins/PLUGIN_ID/errors.spy",
           :alert  => "/clients/CLIENT_ID/plugins/PLUGIN_ID/alerts.spy"}

# set the user
if ARGV.first == "-u"
 ARGV.shift
 $user = ARGV.shift
else
 abort "Usage:  #{$PROGRAM_NAME} -u UUID [CLIENT_DATA_FILE]"
end

# set the password
if ARGV.first == "-p"
 ARGV.shift
 $password = ARGV.shift
else
 abort "Usage:  #{$PROGRAM_NAME} -u UUID [CLIENT_DATA_FILE]"
end

# set the client id
if ARGV.first == "-c"
  ARGV.shift
  $clientid = ARGV.shift
else
  abort "Usage:  #{$PROGRAM_NAME} -u UUID [CLIENT_DATA_FILE]"
end

data_file = ARGV.shift || "client_data.yaml"

require "net/http"
require "uri"
require "yaml"

class Plugin
  class << self
    def last_defined
      @last_loaded
    end
    
    def inherited(new_plugin)
      @last_loaded = new_plugin
    end
    
    def load(last_run, options)
      new(last_run, options)
    end
  end
  
  def initialize(last_run, options)
    @last_run = last_run
    @options  = options
  end
end

# Returns either the path or a full URL. 
# A full URL is returned in the following cases:
#
# * the +url_name+ is a string
# * the :auth => true option is set
#
# A full URL is needed (with login info) when posting.
def urlify(url_name, options = Hash.new)  
  # add authentication info if :auth => true option set or the url is a String.
  auth = options.delete(:auth) or url_name.is_a?(String)

  path = if url_name.is_a?(String)
            url_name
         else
            URLS[url_name].
            gsub(/\bCLIENT_ID\b/, $clientid).
            gsub(/\b[A-Z_]+\b/) { |key| options[key.downcase.to_sym] || key }
         end
         
  if auth
    'http://' + $user + ':' + $password + '@' + $server + path
  else
    path
  end
end

def collapse_params(params, prefix = nil)
  params.inject(Hash.new) do |all, (key, value)|
    if value.is_a? Hash
      all.merge(
        collapse_params(value, prefix ? "#{prefix}[#{key}]" : String(key))
      )
    else
      all.merge((prefix ? "#{prefix}[#{key}]" : String(key)) => String(value))
    end
  end
end

def report(data, plugin_id)
  params = {:report => {:data => data, :plugin_id => plugin_id} }
  post( urlify(:report, :plugin_id => plugin_id),
        "Unable to report to server.",
        params )
end

def alert(data, plugin_id)
  params = {:alert => {:subject => data[:subject], :body => data[:body], :plugin_id => plugin_id} }
  post( urlify(:alert, :plugin_id => plugin_id),
        "Unable to send alert to server.",
        params )
end

def error(data, plugin_id)
  post( urlify(:error, :plugin_id => plugin_id),
        "Unable to log error on server.",
        {:error => {:subject => data[:subject], :body => data[:body], :plugin_id => plugin_id}} )
end


def post(url_name, error, params = {})
  response = Net::HTTP.post_form( URI.parse(urlify(url_name, :auth => true)),
                                  collapse_params(params) )
  case response
  when Net::HTTPSuccess
    yield response if block_given?
  else
    abort error
  end
end

def get(url_name, error, params = {})
  Net::HTTP.start($server.split(':').first,($server.split(':').last != $server.split(':').first ? $server.split(':').last : nil )) {|http|
        req = Net::HTTP::Get.new(urlify(url_name))
        req.basic_auth $user, $password
        
        response = http.request(req)
        
        case response
        when Net::HTTPSuccess
          yield response if block_given?
        else
          abort error
        end
      }
end

unless File.exist? data_file
  File.open(data_file, "w") do |file|
    YAML.dump({"last_runs" => Hash.new}, file)
  end
end
client_data = File.open(data_file) { |file| YAML.load(file) }

get(:plan, "Could not retrieve plan from server.") do |res|
  begin
    Marshal.load(res.body).each do |plan|
      @plan = plan
      if (last_run = client_data["last_runs"][plan[:name]]).nil? or
         Time.now > last_run + plan[:interval]
        eval(plan[:code])
        if plugin = Plugin.last_defined.load( last_run, 
                                              plan[:options] || Hash.new )
          data = plugin.run
          report(data[:report], plan[:plugin_id]) if data[:report]
          if data[:alerts] and data[:alerts].any?
            data[:alerts].each { |a| alert(a, plan[:plugin_id]) }
          end
          error(data[:error], plan[:plugin_id]) if data[:error]
          client_data["last_runs"][plan[:name]] = Time.now
        else
          error({:subject => "Plugin would not load."}, plan[:plugin_id])
        end
      end
    end
  rescue
    error({:subject => "Exception:  #{$!.message}.",:body => $!.backtrace}, @plan[:plugin_id])
  end
end

File.open(data_file, "w") { |file| YAML.dump(client_data, file) }
